% file:         vlfeat.tex
% description:  An introduction to the VisionLab Features Library
% author:       Andrea Vedaldi

\documentclass[9pt]{article}
\usepackage{times}
\usepackage[margin=1.5cm]{geometry}

\usepackage{graphicx,amsmath,amssymb,color,pdfsync}
\usepackage{subfig}
\usepackage{xspace}
\usepackage{ifpdf}
\usepackage{fancyvrb}


\ifpdf
\DeclareGraphicsExtensions{.pdf,.eps,.png}
\usepackage{epstopdf}
\else
\DeclareGraphicsExtensions{.png,.eps,.pdf}
\fi

\newcommand{\VLFeat}{{\sc VLFeat}\xspace}
\newcommand{\block}{\vspace{.5em}\noindent}
\newcommand{\cmd}  [1]{{\color{red}\tt   #1}}
\newcommand{\param}[1]{{\color{red}\tt   #1}}
\newcommand{\real}{\ensuremath{\mathbb{R}}}
\title{An Introduction to the\\ VisionLab Features Library} 
\author{A. Vedaldi, B. Fulkerson}

\CustomVerbatimEnvironment{verbcode}{Verbatim}{formatcom=\small}

% --------------------------------------------------------------------
\begin{document}
% --------------------------------------------------------------------

\ifpdf\twocolumn\fi
\maketitle{}
\ifpdf\tableofcontents{}\fi

% --------------------------------------------------------------------
\section{Introduction}\label{intro}
% --------------------------------------------------------------------

\VLFeat (VisionLab Features Library) is a collection of computer
vision algorithms with a special focus on image features such as SIFT
and MSER. The core algorithms are implemented in a lightweight and
portable C library (the library is documented elsewhere and not
covered by this article) and are made accessible through the library
API, command line programs, and MATLAB programs. The library also
bundels a number of MATLAB utility programs.

There are tree sources of documentation for \VLFeat:
\begin{itemize}\raggedright
\item The built-in help of the MATLAB programs (\verb$help <PROGRAM>$).
\item The Unix MAN pages of the command line programs
  (\verb$man <PROGRAM>$).
\item The documentation of the core C library \cite{}.
\end{itemize}
The documentation of the C library is very useful even for the MATLAB
or command line user as it explains the techinical details of the
algorithm implementations.  This article is an introduction and a
tutorial to \VLFeat and focuses on the MATLAB interface.


% --------------------------------------------------------------------
\section{SIFT}\label{sift}
% --------------------------------------------------------------------

The {\em Scale-Invariant Feature Transform
  (SIFT)}~\cite{lowe04distinctive} bundles a feature detector and a
feature descriptor. A {\em feature detecto}r takes and image $I$ and
selects a number of {\em frames} (``keypoints'', ``interest points'',
``regions''), which are stable image regions. Here ``stable'' means
that the same regions are selected up to a prescribed set of image
transformations (due to noise, viewpoint changes, illumination changes
and so on). A {\em feature descriptor} computes, from the local
appearance of a frame, a {\em descriptors}, a distinctive label that
helps identify the frame.

\begin{figure*}
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_0}
\label{fig:sift-intro-a}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_2}
\label{fig:sift-intro-b}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_3}
\label{fig:sift-intro-c}}
\caption{{\em SIFT: frames and descriptors.} \protect\subref{fig:sift-intro-a}
  a test image, \protect\subref{fig:sift-intro-b} 50 detected features
  \protect\subref{fig:sift-intro-c} and their
  descriptors.}\label{fig:sift-intro}
\end{figure*}

Both the detector and descriptor are accessible by a single MATLAB
program called \cmd{sift} (there is a similar command line
utility). To demonstrate the usage of \cmd{sift}, we open MATLAB and
we load a test image (Fig.~\ref{fig:sift-intro-a}):
\begin{verbatim}
pfx = fullfile(vlfeat_root,'data','a.jpg') ;
I = imread(pfx) ;
image(I) ;
\end{verbatim}
The \verb$sift$ command needs a gray scale image in single
precision. It also expects the image to be normalized in the $[0,255]$
range (although this is not required, the default values of the
various thresholds used by the algorithm are tuned for this
case). This is obained by
\begin{verbatim}
I = float(rgb2gray(I)) ;
\end{verbatim}
We compute the SIFT frames (keypoints) and descriptors by
\begin{verbatim}
[f,d] = sift(I) ;
\end{verbatim}
The matrix \verb$f$ has a column for each frame with the parameters
$(x,y,\sigma,\theta)$. Here $(x,y)$ is the frame center, $\sigma$ the
frame scale (radius) and $\theta$ the frame ortientation. We visualize
a random selection of 50 features (Fig.~\ref{fig:sift-intro-b}) by:
\begin{verbatim}
perm = randperm(size(f,2)) ; 
sel  = perm(1:50) ;
h1   = plotframe(f(:,sel)) ; 
h2   = plotframe(f(:,sel)) ; 
set(h1,'color','y','linewidth',3) ;
set(h2,'color','k','linewidth',1) ;
\end{verbatim}
We can also overlay the descriptors (Fig.~\ref{fig:sift-intro-c}) by
\begin{verbatim}
h3 = plotsiftdescriptor(d(:,sel),f(:,sel)) ;  
set(h3,'color','g') ;
\end{verbatim}

% --------------------------------------------------------------------
\subsection{Detector parameters}\label{sift.parameters}
% --------------------------------------------------------------------

The SIFT detector is controlled mainly by two parameters: the peak
threshold and the (non) edge treshold. 

The {\bf peak treshold} filters peaks of the DoG scale space that are
too small (in absolute value). For instance, consider the test image
(Fig.~\ref{fig:sift-peak-tresh}) obtained as a gradient of Gaussian
blobs:
\begin{verbatim}
I = double(rand(100,500) <= .005) ;
I = (ones(100,1) * linspace(0,1,500)) .* I ;
I(:,1) = 0 ; I(:,end) = 0 ;
I(1,:) = 0 ; I(end,:) = 0 ;
I = 2*pi*4^2 * imsmooth(I,4)
I = single(255 * I) ;
\end{verbatim}
We run the detector with peak treshold \verb$x$ by
\begin{verbatim}
f = sift(I, 'PeakTresh', x) ;
\end{verbatim}
obtaining less and less features (Fig.~\ref{fig:sift-peak-tresh}).

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_4}
\end{center}
\caption{{\em SIFT: peak treshold.} From top to bottom: test image and
  SIFT frames detected for increasing values of the peak treshold.}
\label{fig:sift-peak-tresh}
\end{figure}

The {\bf edge trehsold} instead eliminates peaks of the DoG scale
spcae whose curvature is too small (the reason is that such peaks
yields badly localized frames). For instance, consider the test image
(Fig.~\ref{fig:sift-edge-tresh})
\begin{verbatim}
I = zeros(100,500) ;
for i=[10 20 30 40 50 60 70 80 90]
  I(50-round(i/3):50+round(i/3),i*5) = 1 ;
end
I = 2*pi*8^2 * imsmooth(I,8) ;
I = single(255 * I) ;
\end{verbatim}
We run the detector with edge treshold \verb$x$ by
\begin{verbatim}
f = sift(I, 'EdgeTresh', x) ;
\end{verbatim}
obtaining more and more features (Fig.~\ref{fig:sift-edge-tresh}).

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_4}
\end{center}
\caption{{\em SIFT: edge treshold.} From top to bottom: test image and
  SIFT frames detected for increasing values of the edge
  treshold. Notice that eventually, due to the interaction of nearby
  structures, some ``negative'' blobs are selected too.}
\label{fig:sift-edge-tresh}
\end{figure}

% --------------------------------------------------------------------
\subsection{Custom frames}\label{sift.custom}
% --------------------------------------------------------------------

The MATLAB command \cmd{sift} (and the command line utility) can
bypass the detector and run the descriptor on custom frames by means
of the \param{Frames} option.

\begin{figure}[t]
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_or}
\end{center}
\caption{{\em SIFT: custom frames with computed orientations.}  The
  SIFT detector can be bypassed by specified custom frames (in this
  case on a grid).  Even with custom frames, it is still possible to
  compute the orientations. A kepoint can have multiple orientations,
  and even none if the corresponding image region is flat.  }
\label{fig:sift-custom-or}
\end{figure}

For instance, we can compute the descriptor of a SIFT frame centered
at position $(x,y)=(100,100)$, of scale $\sigma=10$ and orientation
$\theta=\pi/8$ by
\begin{verbatim}
fc = [100;100;10;pi/8] ;
[f,d] = sift(I,'frames',fc) ;
\end{verbatim}
Mutiple frames \verb$fc$ an be specified as well. In this case they
are re-ordered by increasing scale.\footnote{The sorting anglorithm is
  stable, so the natural correspondence custom frames descriptors can
  be preserved by making sure to pass to the function a set of
  pre-predered frames.} The \param{Orientations} option insturcts the
program to use the custom position and scale but to compute the
keypoint orientations, as in
\begin{verbatim}
fc = [100;100;10;0] ;
[f,d] = sift(I,'frames',fc,'orientations') ;
\end{verbatim}
Notice that, depending on the local appearance, a keypoint cmay have
{\em multiple} orientations.  Moreover, a keypoint computed on a
constant image region (such as one big as one pixel) has no
orientations (Fig.~\ref{fig:sift-custom-or})!

% --------------------------------------------------------------------
\subsection{Conventions}\label{sift.conventions}
% --------------------------------------------------------------------

In our implementation SIFT frames are expressed in the standard image
reference.  The only difference between the command line and MATLAB
drivers is that the latter assumes that the image origin (top-left
corner) has coordinate $(1,1)$ as opposed to $(0,0)$. Lowe's original
implementation uses a different reference system. The details are
illustrated in Fig.~\ref{fig:sift-conv}

\begin{figure}
\begin{center}
\includegraphics[width=1.0\columnwidth]{figures/sift-conv}
\end{center}
\caption{{\em SIFT: conventions.} {\bf Top.} Our implementation uses
  the standard image reference systesm, with the $y$ axis pointing
  downard. The frame orientation $\theta$ and descriptor use the same
  reference system (i.e. a small positive rotation of the $x$ moves it
  towards the $y$ axis). Recall that each descriptor elment is a bin
  indexed by $(\theta,x,y)$; the histogram is vectorized in such a way
  that $\theta$ is the fastest varying index and $y$ the slowest. {\bf
    Bottom.} D. Lowe's implementation~\cite{lowe07sift} uses a
  slightly different convention: Frames centers are expressed
  relatively to the standard image reference system, but the frames
  orientation and the descriptor assume that the $y$ axis points
  upward. Consequently, to map from our to D. Lowe's convention,
  frames orientations need to be transformed ($\theta'=-\theta$) and
  the descriptor elements must be re-arranged.}
\label{fig:sift-conv}
\end{figure}

% --------------------------------------------------------------------
\subsection{Conformity}\label{sift.conformity}
% --------------------------------------------------------------------

Our implementation produces SIFT frames and descriptors that are
almost identical to D. Lowe's original
implementation~\cite{lowe07sift}
(Fig.~\ref{fig:sift-conformity}). Small differences are due to
numerical errors and a minor difference in the computation of the
frames orientations (we eliminated a small bias introduce by Lowe's
original implementation). The only known issue is that a small number
of frames are detected by one implementation but not the other.

\begin{figure}
\begin{center}
\subfloat[]{
\includegraphics[width=0.49\columnwidth]{figures/demo/sift_cmd_1}
\label{fig:sift-custom.a}
}\hfill
\subfloat[]{
\includegraphics[width=0.49\columnwidth]{figures/demo/sift_cmd_2}
\label{fig:sift-custom.b}
}\\
\end{center}
\caption{{\em SIFT: comparison to Lowe's original implementation.}
  \protect\subref{fig:sift-custom.a} SIFT frames detected by our
  implementation (both through the MATLAB and command line interfaces)
  and the original Lowe's implementation: there is a very good
  correspondence (up to numerical errors).  Notice that a few frames
  are detected by one implementation but not the other.
  \protect\subref{fig:sift-custom.b} The same for the SIFT descriptors
  of some of the frames: again the correspondence is very good.}
\label{fig:sift-conformity}
\end{figure}

% --------------------------------------------------------------------
\section{MSER}\label{mser}
% --------------------------------------------------------------------

{\em Maximally Stable Extremal Regions (MSER)}~\cite{matas03robust} is
a feature detector; Analogously to the SIFT detector (see
Sect.~\ref{sift}), the MSER algorithm takes and image $I$ and extracts
a number of feature frames (Fig.~\ref{fig:mser-intro}). Frames are
either the MSERs or ellipsoids fitted to them. An MSER is a {\em
  stable} connected component of some level sets
$\{x:I(y)\leq\gamma\}, \gamma\in\real$ of the image $I$.

\begin{figure*}[t]
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_0}
\label{fig:mser-intro-a}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_1}
\label{fig:mser-intro-b}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_2}
\label{fig:mser-intro-c}}
\caption{{\em MSER: frames} \protect\subref{fig:sift-intro-a} a test
  image, \protect\subref{fig:sift-intro-b} detected MSERs (positive
  and negative), \protect\subref{fig:sift-intro-c} MSERs as fitted
  ellipses.}
\label{fig:mser-intro}
\end{figure*}

A single pixel $x$ ({\em seed}) is sufficient to identify any MSER as
the connected component of the level set of intensity $\gamma=I(x)$
which contains the pixel $x$. MSERs, as identified by {\em seeds},
have arbitrary shape (Fig.~\ref{fig:mser-intro-b}). Usually their
shape is simplified by fitting ellipsoids, as exemplified in
(Fig.~\ref{fig:mser-intro-c}).

To demonstrate the usage of \cmd{mser}, we open MATLAB and we load a
test image (Fig.~\ref{fig:sift-intro-a}):
\begin{verbatim}
pfx = fullfile(vlfeat_root,'data','spots.jpg') ;
I = imread(pfx) ;image(I) ; 
\end{verbatim}
We then convert the image to a format that is suitable for the
\cmd{mser} command.
\begin{verbatim}
I = uint8(rgb2gray(I)) ;
\end{verbatim}
We compute the region seeds and frames by
\begin{verbatim}
[r,f] = mser(I,'MinDiversity',0.7,...
               'MaxVariation',0.2,...
               'Delta',10) ;
\end{verbatim}
We plot the region frames by
\begin{verbatim}
clf ; imagesc(I) ; 
hold on ;
f = ertr(f) ;
plotframe(f) ;
\end{verbatim}
The \cmd{ertr} transposes the elliptical frame and is needed because
the \cmd{mser} code assumes that the row index is the first index, but
the normal image convention assumes that this is the $x$ (column)
index.

Plotting the MSERs themselves is a bit more involved as they have
arbitrary shape.  To this end, we exploit two functions: \cmd{erfill},
which, given an image and a region seed, returns a list of the pixels
belonging to that region, and MATLAB built-in \cmd{contourn}, which
draws the contour lines of a function. We start by
\begin{verbatim}
M = zeros(size(I)) ;
for x=r'
 s = erfill(I,x) ;
 M(s) = M(s) + 1;
end
\end{verbatim}
which computes a matrix \verb$M$ whose value are equal to the number
of overlapping extremal regions. Next, we use \verb$M$ and
\cmd{contourn} to display the region boundaries:
\begin{verbatim}
clf ; imagesc(I) ;
hold on ;
[c,h]=contourn(M,(0:max(M(:)))+.5) ;
\end{verbatim}

% --------------------------------------------------------------------
\subsection{MSER parameters}\label{mser.parameters}
% --------------------------------------------------------------------

In~\cite{matas03robust}, MSERs are controlled by a single parameter
$\Delta$. Our implementation uses a few more parameters to refine even
more the selection of the useful extremal regions.

Understanding the parameters requires to know how ``stability'' of an
extremal region is defined. The stability of an extremal region $R$ is
the inverse of the relative area variation of the region $R$ when the
intensity level is increased by $\Delta$. Formally, the area variation
is defined as $|R_{+\Delta} - R|/|R|$, where $|R|$ denotes the area of
the extremal region $R$, $R_{+\Delta}$ is the extremal region
$+\Delta$ levels up which contains $R$ and $R_{+\Delta} - R$ is the
set difference of the two regions. If the are variation is small, then
the region is deemed stable.

Based on the stability score, the algorithm keeps the extremal regions
which are maximally stable, meaning that they have minimum variation
compared to the extremal region one intensity level below and one
intensity level up\footnote{Due to the discrete nature of the image,
  the region below/up may be coincident with the actual region, in
  which case the region is still deemed maximal.}. Even if an extremal
region is maximally stable, it might be rejected if
\begin{itemize}
\raggedright
\item it is too big (see the parameter \param{MaxArea});
\item it is too small (see the parameter \param{MinArea});
\item it is too unstable (see the parameter \param{MaxVariation});
\item it is too similar to another MSER (see the
  paramter \param{MinDiversity}).
\end{itemize}

The interpretation of the parameters \param{MaxArea}
and \param{MinArea}. The parameter \verb$MaxVariation$ removes regions
that are too unstable (even if they might be maximally stable in the
local). The interaction of \verb$MaxVariation$ and \verb$Detla$ is
illustrated in Fig.~\ref{fig:mser-delta}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_4}
\end{center}
\caption{{\em MSER: role of the paramter $\Delta$} {\bf Top.} The intensity profile. The bumps
have heights equal to $32,64,96,128$ and $160$ intensity levels. {\bf Other rows.} The variation score of a bump is either $0$ if $\Delta$ is smaller than the bump height or very large otherwise (as the next extremal region is as big as the whole image). 
\param{MaxVariation} is set to 0.25.}
\label{fig:mser-delta}
\end{figure}

While the concept of local stability is simple to grasp, there is a
complication that we did not address yet, i.e. how to define
``locality'' in the comparison of extremal regions. In a senseFor
instance, one could define neighbors of an extremal region $R$ the
parent extremal region $R_{+1}$ at level e would compare the region
$R$ with the region $R_{+1}$ and

% --------------------------------------------------------------------
\subsection{Conventions}\label{mser.command}
% --------------------------------------------------------------------

As mentioned in the introduction, the \cmd{mser} uses the matrix
indeces as image coordinates. Compared to the usual MATLAB convention
for images, this means that the $x$ and $y$ axis are swapped (this has
been done to make the convention consistent with images with three or
more dimensions). Thus the frames computed by the program may need to
be ``transposed'' as in:
\begin{verbatim}
[r,f] = mser(I) ;
f = ertr(f) ;
\end{verbatim}
On the other hand, the region seeds \verb$r$ are already in row
major format, which is how MATLAB standard format for  pixel indeces.

Instead of transposing the frames, one can start by transoposing the
image. In this case, the frames \verb$f$ have the standard image
convention, but the region seeds are in column-major format and may
need to be ``transopsed'' as in:
\begin{verbatim}
[r,f] = mser(I') ;
[i,j] = sub2ind(size(I'),r) ;
r  = ind2sub(size(I),j,i) ; 
\end{verbatim}

The command line utility \cmd{mser} uses the normal image convention
(because images are rasterized in column-major order). Therefore the
image frames are in the standard format, and the region seeds are in
column major format.

In order to convert from the command line utility convention and the
MATLAB convention one needs also to recall that MATLAB coordinates 
starts from $(1,1)$, but the command line utility uses the more common
convention $(0,0)$. For instance, let the files \verb$image.frame$ and
\verb$image.seed$ contain the feature frames and seeds in ASII format
as generated by the command line utility. Then 
\begin{verbatim}
r_ = load('image.seed')' + 1 ;
f_ = load('image.frame')' ; 
f_(1:2,:) = f_(1:2,:) + 1 ;
[r,f] = mser(I') ; % notice the transpose
\end{verbatim}
produces identical (up to numerical noise) region seeds \verb$r$ and
\verb$r_$ and frames \verb$f$ and \verb$f_$.

% --------------------------------------------------------------------
\subsection{Conformity}\label{mser.conformity}
% --------------------------------------------------------------------

The specification of the MSER algorithm~\cite{matas03robust} leaves
some details on how the stability score is computed unspecified. This
implementation uses a slightly simplified version of the stability
score and introduces some additional parameters to control the
selection of the useful MSER. The details are illustrated
in~\cite{vedaldi07vlfeat-dox}.

% --------------------------------------------------------------------
\section{Integer K-means}\label{ikmeans}
% --------------------------------------------------------------------

\VLFeat includes a basic implementation of $K$-means clustering and
hierarchical $K$-means clustering. They are designed to be lightweight
in order to work on large dataset. In particular, they assume that the
data are vectors of usigned chars (one byte). While this is limiting
for some application, works well for clustering image descriptors,
where usually very high precision is unnecessary.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/ikmeans}\\
\end{center}
\caption{{\em Integer K-means}. We show clusters of 2-D points
  obtained by integer K-means.  There are $K=3$ clusters represented
  with different colors. The clusters have been estimated from 1000
  points (displayed as dots). Then other 10000 points have been
  projected on the same clusters (displayed as crosses). The three big
  markers represent the cluster centers.}
\label{fig:ikmeans}
\end{figure}

Integer K-means (IKM) is run by the command \cmd{ikmeans}. In order to
demonstrate the usage of this command, we sample 10000 random points
in the $[0,255]^2$ integer square and launch the \cmd{ikmeans} to get
$K=3$ clusters:
\begin{verbatim}
K = 3 ;
data = uint8(rand(2,10000) * 255) ;
[C,A] = ikmeans(data,K) ;
\end{verbatim}
The program returns both the cluster centers \verb$C$ and the
data-to-cluster assignments $A$. By means of the cluster centers
\verb$C$ we can project more data on the same clusers
\begin{verbatim}
datat = uint8(rand(2,100000) * 255) ;
AT = ikmeanspush(datat,C) ;
\end{verbatim}
In order to visualize the results, we associate to each cluster a
color and we plot the points:
\begin{verbcode}
cl = get(gca,'ColorOrder') ;
ncl = size(cl,1) ;
for k=1:K
  sel  = find(A  == k) ;
  selt = find(AT == k) ;
  plot(data(1,sel),  data(2,sel),  '.',...
       'Color',cl(mod(k,ncl)+1,:)) ;
  plot(datat(1,selt),datat(2,selt),'+',...
       'Color',cl(mod(k,ncl)+1,:)) ;  
end
\end{verbcode}
The results are shown in Fig.~\ref{fig:ikmeans}.


% --------------------------------------------------------------------
\subsection{Hierarchical IKM}\label{ikmeans.hierarchical}
% --------------------------------------------------------------------

\VLFeat also offers a hierarchical version of integer K-means, which
recusively apply \cmd{ikmeans} to compute finer and finer partitions.
We demonstrates this by:
\begin{verbatim}
K        = 3 ;
nleaves  = 100 ;
data     = uint8(rand(2,10000) * 255) ;
datat    = uint8(rand(2,100000)* 255) ;
[tree,A] = hikmeans(data,K,nleaves) ;
AT       = hikmeanspush(tree,datat) ;
\end{verbatim}
Here \verb$nleaves$ is the desired number of leaf clusters. This is
obtained by subdividing recursively each cluster in $K$
sub-clusters. Therefore $\mathtt{depth} = \lfloor \log_K
\mathtt{nleaves} \rfloor$ recursive subdivisons are sufficient and the
algorithm terminates with clusters arranged in a $K$-tree of of depth
\verb$depth$ which has at least \verb$nleaves$ leaves (but it may have
more).

\begin{figure}
\begin{center}
\includegraphics[width=0.4\columnwidth]{figures/demo/hikmeans-tree}\hfill
\includegraphics[width=0.4\columnwidth]{figures/demo/hikmeans-clusters}\\
\end{center}
\caption{{\em Hierarchical integer K-means}. {\bf Left.} A depiction
  of the rescursive clsuters. Each node is a cluster center. The root
  note is not depicted (its center would be the mean of the dataset).
  {\bf Right}. Clusters are represented as different colors (here are
  more thatn 100 clusters, but only tree colors are used).}
\label{fig:hikmeans}
\end{figure}

The output \verb$tree$ is a MATLAB structure representing the tree of
clusters:
\begin{verbatim}
> tree
tree =
 
          K: 3
      depth: 5
    centers: [2x3 int32]
        sub: [1x3 struct]
\end{verbatim}
The field \verb$centers$ is the matrix of the cluster centers at the
root node.  If the depth of the tree is larger than 1, then the field
\verb$sub$ is a structure array with one entry for each cluster. Each
element is in turn a structure such as
\begin{verbatim}
> tree.sub
ans = 

1x3 struct array with fields:
    centers
    sub
\end{verbatim}
with teh cluster centers for that recusrive parittions and a field
\verb$sub$ for the recursive children. When there are no childrent,
this field is equal to the empty matrix
\begin{verbatim}
K>> tree.sub(1).sub(1).sub(1).sub(1)

ans = 

    centers: [2x3 int32]
        sub: []
\end{verbatim}
Fig.~\ref{fig:hikmeans} illustrates the recusrive partitons obtained
for the 2-D points data.




% --------------------------------------------------------------------
\section{MATLAB utility programs}\label{other}
% --------------------------------------------------------------------
This is a list of other useful MATLAB programs bundled with \VLFeat:
\begin{itemize}
\raggedright
\item \cmd{imsmooth} smoothes an image by a Gaussian kernel (simple
  but very useful as it is generally much faster than MATLAB general
  purpose smoothing functions).
\item \cmd{plotframe} plots a variety of feature frame kinds.
\item \cmd{binsum} performs binned summations, useful as a building
  block for the fast computation of histograms. \cmd{whistc} computed
  weighed histograms.
\item \cmd{imarray} and \cmd{imarraysc} arrange and visualize multiple
  images in a grid; \cmd{imsc} scales the image range;
  \cmd{tightsubplot} is similar to built-in \cmd{subplot}, but
  produces narrower margins.
\item \cmd{cf} copies a figure.
\item \cmd{rord} and \cmd{irodr} compute the Rodrigues' formula and
  its inverse.
\item \cmd{override} overrides members of a structure with members of
  another strucutre.
\item \cmd{imwbackward} warps an image by the inverse mapping method
  (generally much faster than MATLAB general purpose warping
  functions).
\item \cmd{waffine} computes the affine warp of a set of
  points. \cmd{tps}, \cmd{tpsu}, \cmd{wtps} compute the thin-plate
  spline warp of a set of points. \cmd{witps} computes the inverse
  thin plate warp of a set of point (by numerically inverting the
  transformation). They may me used in combination with
  \cmd{imwbackward}.
\item \cmd{xyz2lab}, \cmd{xyz2luv}, \cmd{xyz2rgb}, \cmd{rgb2xyz}
  convert color spaces.
\item \cmd{rcos}, \cmd{gaussian}, \cmd{dgaussian}, \cmd{ddgaussian}
  compute some basic functions.
\end{itemize}

% --------------------------------------------------------------------
\raggedright
\bibliographystyle{IEEEtran}
\bibliography{bibliography}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\end{document}
% --------------------------------------------------------------------