% file:         vlfeat.tex
% description:  An introduction to the VisionLab Features Library
% author:       Andrea Vedaldi

\documentclass{article}

\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}
\usepackage{subfig}
\usepackage{xspace}
\usepackage{ifpdf}
%\usepackage{visionlab}

\ifpdf
\DeclareGraphicsExtensions{.pdf,.eps,.png}
\usepackage{epstopdf}
\else
\DeclareGraphicsExtensions{.png,.eps,.pdf}
\fi

\newcommand{\VLFeat}{{\sc VLFeat}\xspace}
\newcommand{\block}{\vspace{.5em}\noindent}
\title{An Introduction to the\\ VisionLab Features Library}
\author{Andrea Vedaldi \and Brian Fulkerson}

% --------------------------------------------------------------------
\begin{document}
% --------------------------------------------------------------------

\ifpdf\twocolumn\fi
\maketitle{}
\ifpdf\tableofcontents{}\fi

% --------------------------------------------------------------------
\section{Introduction}\label{intro}
% --------------------------------------------------------------------

\VLFeat (VisionLab Features Library) is a collection of computer
vision algorithms with a special focus on image features detection and
extraction such as SIFT and MSER. The core algorithms are implemented
in a lightweight and portable C-90 library (this library is documented
elsewhere and not covered by this article). The algorithms are made
accessible to the end user as command line and MATLAB programs.

This article provides a tutorial introduction to the main features of
\VLFeat. For a detailed description of the MATLAB and command line
utilites, the reader is referred to the relative built-in and
\verb$man$ documentation (respectively). For an overview of the
algorithms and their parameters, it is also reccomended to refer to
the documentation of the core library [].

% --------------------------------------------------------------------
\section{SIFT}\label{sift}
% --------------------------------------------------------------------

SIFT (scale-invariant feature transform) bundles a feature detector
and a feature descriptor. A feature detector selects {\em frames}
(also called ``keypoint'', ``interest points'', ``regions''), which
are stable image regions. Here ``stable'' means that the same regions
are selected up to a prescribed set of image transformations (for
instance noise, viewpoint change or illumination change). A feature
descriptor computes, from the local appearance of each frame, a {\em
  descriptors}, which is a distinctive lable that identifies robustly
the frame.

\begin{figure*}
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_0}
\label{fig:sift-intro-a}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_2}
\label{fig:sift-intro-b}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_3}
\label{fig:sift-intro-c}}
\caption{{\em SIFT: frames and descriptors.} \protect\subref{fig:sift-intro-a}
  a test image, \protect\subref{fig:sift-intro-b} 50 detected features
  \protect\subref{fig:sift-intro-c} and their
  descriptors.}\label{fig:sift-intro}
\end{figure*}

Both the detector and descriptor are accessible by a single MATLAB
program \verb$sift$ (there is a similar command line utility). To
demonstrate the usage of \verb$sift$, we open MATLAB and we load a
test image (Fig.~\ref{fig:sift-intro-a}):
\begin{verbatim}
pfx = fullfile(vlfeat_root,'data','a.jpg') ;
I = imread(pfx) ;
image(I) ;
\end{verbatim}
The \verb$sift$ command needs a gray scale image in single
precision. It also expects the image to be normalized in the $[0,255]$
range (although this is not required, the default values of the
various thresholds used by the algorithm are tuned for this
case). This is obained by
\begin{verbatim}
I = float(rgb2gray(I)) ;
\end{verbatim}
We compute the SIFT frames (keypoints) and descriptors by
\begin{verbatim}
[f,d] = sift(I) ;
\end{verbatim}
The matrix \verb$f$ has a column for each frame with the parameters
$(x,y,\sigma,\theta)$. Here $(x,y)$ is the frame center, $\sigma$ the
frame scale (radius) and $\theta$ the frame ortientation. We visualize
a random selection of 50 features (Fig.~\ref{fig:sift-intro-b}) by:
\begin{verbatim}
perm = randperm(size(f,2)) ; 
sel  = perm(1:50) ;
h1   = plotframe(f(:,sel)) ; 
h2   = plotframe(f(:,sel)) ; 
set(h1,'color','y','linewidth',3) ;
set(h2,'color','k','linewidth',1) ;
\end{verbatim}
We can also overlay the descriptors (Fig.~\ref{fig:sift-intro-c}) by
\begin{verbatim}
h3 = plotsiftdescriptor(d(:,sel),f(:,sel)) ;  
set(h3,'color','g') ;
\end{verbatim}

% --------------------------------------------------------------------
\subsection{Detector parameters}\label{sift.parameters}
% --------------------------------------------------------------------

The SIFT detector is controlled mainly by two parameters: the peak
threshold and the (non) edge treshold. 

The {\bf peak treshold} filters peaks of the DoG scale space that are
too small (in absolute value). For instance, consider the test image
(Fig.~\ref{fig:sift-peak-tresh}) obtained as a gradient of Gaussian
blobs:
\begin{verbatim}
I = double(rand(100,500) <= .005) ;
I = (ones(100,1) * linspace(0,1,500)) .* I ;
I(:,1) = 0 ; I(:,end) = 0 ;
I(1,:) = 0 ; I(end,:) = 0 ;
I = 2*pi*4^2 * imsmooth(I,4)
I = single(255 * I) ;
\end{verbatim}
We run the detector with peak treshold \verb$x$ by
\begin{verbatim}
f = sift(I, 'peaktresh', x) ;
\end{verbatim}
obtaining less and less features (Fig.~\ref{fig:sift-peak-tresh}).

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_4}
\end{center}
\caption{{\em SIFT: peak treshold.} From top to bottom: test image and
  SIFT frames detected for increasing values of the peak treshold.}
\label{fig:sift-peak-tresh}
\end{figure}

The {\bf edge trehsold} instead eliminates peaks of the DoG scale
spcae whose curvature is too small (the reason is that such peaks
yields badly localized frames). For instance, consider the test image
(Fig.~\ref{fig:sift-edge-tresh})
\begin{verbatim}
I = zeros(100,500) ;
for i=[10 20 30 40 50 60 70 80 90]
  I(50-round(i/3):50+round(i/3),i*5) = 1 ;
end
I = 2*pi*8^2 * imsmooth(I,8) ;
I = single(255 * I) ;
\end{verbatim}
We run the detector with edge treshold \verb$x$ by
\begin{verbatim}
f = sift(I, 'peaktresh', x) ;
\end{verbatim}
obtaining more and more features (Fig.~\ref{fig:sift-edge-tresh}).

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_4}
\end{center}
\caption{{\em SIFT: edge treshold.} From top to bottom: test image and
  SIFT frames detected for increasing values of the edge
  treshold. Notice that eventually, due to the interaction of nearby
  structures, some ``negative'' blobs are selected too.}
\label{fig:sift-edge-tresh}
\end{figure}

% --------------------------------------------------------------------
\subsection{Custom frames}\label{sift.custom}
% --------------------------------------------------------------------

The MATLAB command \verb$sift$ (and the command line utility) can
bypass the detector and run the descriptor on custom frames.

%\begin{figure}
%\begin{center}
%\includegraphics[width=0.7\columnwidth]{figures/demo/sift_basic_4}
%\end{center}
%\caption{{\em SIFT: custom frames.} The descriptor computed at a
%  custom frame.}
%\label{fig:sift-custom}
%\end{figure}

For instance, we can compute the descriptor of a SIFT frame centered
at position $(x,y)=(100,100)$, of scale $\sigma=10$ and orientation
$\theta=\pi/2$ by
\begin{verbatim}
fc = [100;100;10;pi/8] ;
[f,d] = sift(I,'frames',fc) ;
\end{verbatim}
Mutiple frames \verb$fc$ an be specified as well. In this case they
are re-ordered by increasing scale.\footnote{The sorting anglorithm is
  stable, so the natural correspondence custom frames descriptors can
  be preserved by making sure to pass to the function a set of
  pre-predered frames.}


% --------------------------------------------------------------------
\subsection{Conventions}\label{sift.conventions}
% --------------------------------------------------------------------

Our implementation SIFT frames are expressed in the standard image
reference.  The only difference between the command line and MATLAB
version is that the latter assumes that the image origin (top-left
corner) has coordinate $(1,1)$ as opposed to $(0,0)$. Lowe's original
implementation uses a different reference system, so if the two implementations
are to be compared the necessary conversion needs to be performed.
The details are illustrated in Fig.~\ref{fig:sift-conv}


\begin{figure}
\begin{center}
\includegraphics[width=1.0\columnwidth]{figures/sift-conv}
\end{center}
\caption{{\em SIFT: conventions.} {\bf Top.} Our implementation uses
  the standard image reference systesm, with the $y$ axis pointing
  donward. The frame orientation $\theta$ and descriptor are expressed
  in the same reference system (i.e. a small positive rotation of $x$
  moves it towards $y$). Recall that each descriptor elment is a bin
  indexed by $(\theta,x,y)$; the histogram is vectorized in such a way
  that $\theta$ is the most quickly varying index and $y$ the
  slowest. {\bf Bottom.} Lowe's implementation uses a slightly
  different convention: frames centers are expressed relative to the
  standard image reference system, but the frame orientation and the
  descriptor assume that the $y$ axis points upward. Consequently,
  frames orientations need to be transformed ($\theta'=-\theta$) and
  descriptor elements re-arranged.}
\label{fig:sift-conv}
\end{figure}

% --------------------------------------------------------------------
\subsection{Conformity}\label{sift.conformity}
% --------------------------------------------------------------------

Our implementation produces SIFT frames and descriptors that are
almost identical to Lowe's original implementation
(Fig.~\ref{fig:sift-conformity}). Small differences are due to
numerical errors, a small details in the computation of the
orientation (Lowe's original implementation has a very small bias that
we eliminated). The most significant difference is that a few
keypoints which are detected by our implementation are not detected by
Lowe's and vice-versa.

\begin{figure}
\begin{center}
\subfloat[]{
\includegraphics[width=0.49\columnwidth]{figures/demo/sift_cmd_1}
\label{fig:sift-custom.a}
}\hfill
\subfloat[]{
\includegraphics[width=0.49\columnwidth]{figures/demo/sift_cmd_2}
\label{fig:sift-custom.b}
}\\
\end{center}
\caption{ {\em SIFT: comparison to Lowe's original implementation.}
  \protect\subref{fig:sift-custom.a} SIFT frames detected by our
  implementation (both through the MATLAB and command line interfaces)
  and the original Lowe's implementation: there is a very good
  correspondence (up to numerical errors).  Noice however that a few
  frames are detected by one implementation but not the other.
  \protect\subref{fig:sift-custom.b} The same for the sift descriptors of some
  of the frames: again the correspondence is very good.}
\label{fig:sift-conformity}
\end{figure}

% --------------------------------------------------------------------
\section{MSER}\label{mser}
% --------------------------------------------------------------------

MSER is a feature detector (Fig.~\ref{fig:mser-intro}). Analogously to
the SIFT detector (see Sect.~\ref{sift}), the MSER algorithm
takes and image and extracts a number of feature frames. The frames
are the maximally stable extremal regions (MSERs) of the image. A MSER
is just a connected component of one of the level sets $\{x:I(y)\leq
\gamma\}$ of intensity $\gamma$ of the iamge $I$.

\begin{figure*}[h]
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_0}
\label{fig:mser-intro-a}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_1}
\label{fig:mser-intro-b}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_2}
\label{fig:mser-intro-c}}
\caption{{\em MSER: frames} \protect\subref{fig:sift-intro-a}
  a test image, \protect\subref{fig:sift-intro-b} detected MSERs (positive and negative), \protect\subref{fig:sift-intro-c} MSERs as fitted ellipses.}
\label{fig:mser-intro}
\end{figure*}

An MSER can be identified by a single pixel $x$, called {\em seed}, as
the connected compoment of intensity $\gamma=I(x)$ which contains the
pixel $x$. Notice that not all pixels of a regions are seeds, but
there exists at least one.

Notice that MSERs have arbitrary shape
(Fig.~\ref{fig:mser-intro-b}). Usually they are simplified by fitting
to them ellipsoids, as in (Fig.~\ref{fig:mser-intro-c}).

% --------------------------------------------------------------------
\section*{References}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\subsection*{Acknowledgments}
% --------------------------------------------------------------------


% --------------------------------------------------------------------
\end{document}
% --------------------------------------------------------------------