<p><em>Maximally Stable Extremal Regions (MSER)</em> is a feature
detector; Analogously to the <a href="tut.sift">SIFT detector</a>, the
MSER algorithm extracts from an image <code>I</code> a number of
co-variant regions, called MSERs. An MSER is a <em>stable</em>
connected component of some level sets of the
image <code>I</code>. Optionally, elliptical frames are attached to
the MSERs by fitting ellipses.</p>

<ul>
<li><a href="tut.mser.extract">Extracting MSERs</a></li>
<li><a href="tut.mser.param">MSER parameters</a></li>
<li><a href="tut.mser.conventions">Conventions</a></li>
</ul>

<!-- ------------------------------------------------------------- -->
<h1 id="tut.mser.extract">Extracting MSERs</h1>
<!-- ------------------------------------------------------------- -->

<div class="figure">
<image src="%root;demo/mser_basic_0.jpg"/>
<div class="caption">
A test image.
</div>
</div>

<div class="figure">
<image src="%root;demo/mser_basic_1.jpg"/>
<image src="%root;demo/mser_basic_2.jpg"/>
<div class="caption">
Extracted MSERs (left) and fitted ellipses (right).
</div>
</div>

<p>Each MSERs can be identified uniquely by (at least) one of its
pixels <code>x</code>, as the connected component of the level set at
level <code>I(x)</code> which contains <code>x</code>. Such a pixel is
called <em>seed</em> of the region.</p>

<p>To demonstrate the usage of the MATLAB command <code>mser</code>
(there is a similarly named command line utility as well), we open
MATLAB and we load a test image</p>
<pre>
pfx = fullfile(vl_root,'data','spots.jpg') ;
I = imread(pfx) ;
image(I) ; 
</pre>
<p>We then convert the image to a format that is suitable for the
<code>mser</code> command.</p>

<pre>
I = uint8(rgb2gray(I)) ;
</pre>

<p>We compute the region seeds and the elliptical frames by</p>
<pre>
[r,f] = vl_mser(I,'MinDiversity',0.7,...
                'MaxVariation',0.2,...
                'Delta',10) ;
</pre>

<p>We plot the region frames by</p>

<pre>
clf ; imagesc(I) ; 
hold on ;
f = vl_ertr(f) ;
vl_plotframe(f) ;
</pre>

<p>The <code>vl_ertr</code> transposes the elliptical frame and is needed
because the <code>mser</code> code assumes that the row index is the
first index, but the normal image convention assumes that this is the
<code>x</code> (column) index.</p>

<p>Plotting the MSERs themselves is a bit more involved as they have
arbitrary shape.  To this end, we exploit two functions: <code>vl_erfill</code>,
which, given an image and a region seed, returns a list of the pixels
belonging to that region, and MATLAB built-in <code>contourn</code>, which
draws the contour lines of a function. We start by</o>

<pre>
M = zeros(size(I)) ;
for x=r'
 s = vl_erfill(I,x) ;
 M(s) = M(s) + 1;
end
</pre>

<p>which computes a matrix <code>M</code> whose value are equal to the
number of overlapping extremal regions. Next, we use <code>M</code>
and <code>contourn</code> to display the region boundaries:</o>

<pre>
clf ; imagesc(I) ;
hold on ;
[c,h]=contourn(M,(0:max(M(:)))+.5) ;
</pre>

<!-- ------------------------------------------------------------- -->
<h1 id="tut.mser.param">MSER parameters</h1>
<!-- ------------------------------------------------------------- -->

<p>In the original formulation, MSERs are controlled by a single
parameter <code>&Delta;</code>. Our implementation uses a few more
parameters to refine even more the selection of the useful extremal
regions.</p>

<p>Understanding the parameters requires to know how ``stability'' of
an extremal region is defined. The stability of an extremal
region <code>R</code> is the inverse of the relative area variation of
the region <code>R</code> when the intensity level is increased by
<code>&Delta;</code>. Formally, the area variation is defined as 
<code>|R(+&Delta;) - R(-&Delta;)|/|R|</code>, where $|R|$ denotes the
area of the extremal region <code>R</code>, <code>R(+&Delta;)</code>
is the extremal region <code>+&Delta;</code> levels up which
contains <code>R</code> and <code>R(+&Delta;) - R</code> is the set
difference of the two regions. If the are variation is small, then the
region is deemed stable.</p>

<p>Based on the stability score, the algorithm keeps the extremal regions
which are maximally stable, meaning that they have minimum variation
compared to the extremal region one intensity level below and one
intensity level up\footnote{Due to the discrete nature of the image,
  the region below/up may be coincident with the actual region, in
  which case the region is still deemed maximal.}. Even if an extremal
region is maximally stable, it might be rejected if

<ul>
<li>it is too big (see the parameter <code>MaxArea</code>);</li>
<li>it is too small (see the parameter <code>MinArea</code>);</li>
<li>it is too unstable (see the parameter <code>MaxVariation</code>);</li>
<li>it is too similar to another MSER (see the
paramter <code>MinDiversity</code>).</li>
</ul>

<p>The interpretation of the parameters <code>MaxArea</code> and
<code>MinArea</code>. The parameter <code>MaxVariation</code> removes
regions that are too unstable (even if they might be maximally stable
in the local). The interaction of the various parameters are
illustrated next.</p>

<div class="figure">
<image src="%root;demo/mser_delta_0.jpg"/>
<image src="%root;demo/mser_delta_1.jpg"/>
<image src="%root;demo/mser_delta_2.jpg"/>
<image src="%root;demo/mser_delta_3.jpg"/>
<image src="%root;demo/mser_delta_4.jpg"/>
<div class="caption">
<b>Meaning of parameter <code>&Delta;</code>.</b>  The intensity
profile. The bumps have heights equal to 32, 64, 96, 128 and 160
intensity levels. The variation score of a bump is either 0 if &Delta;
is smaller than the bump height or very large otherwise (as the next
extremal region is as big as the whole
image). <code>MaxVariation</code> is set to 0.25.
</div>
</div>

<p>While the concept of local stability is simple to grasp, there is a
complication that we did not address yet, i.e. how to define
``locality'' in the comparison of extremal regions. For
instance, one could define neighbors of an extremal region $R$ the
parent extremal region <code>R(+1)</code> at level e would compare the region
<code>R</code> with the region <code>R_{+1}</code>.

<!-- ------------------------------------------------------------- -->
<h1 id="tut.mser.conventions">Conventions</h1>
<!-- ------------------------------------------------------------- -->


<p>As mentioned in the introduction, the <code>mser</code> uses the
matrix indices as image coordinates. Compared to the usual MATLAB
convention for images, this means that the <code>x</code>
and <code>y</code> axis are swapped (this has been done to make the
convention consistent with images with three or more dimensions). Thus
the frames computed by the program may need to be ``transposed'' as
in:</p>

<pre>
[r,f] = vl_mser(I) ;
f = vl_ertr(f) ;
</pre>

<p>On the other hand, the region seeds <code>r</code> are already in
row major format, which is how MATLAB standard format for pixel
indices.</p>

<p>Instead of transposing the frames, one can start by transposing
the image. In this case, the frames <code>f</code> have the standard
image convention, but the region seeds are in column-major format and
may need to be ``transposed'' as in:</p>

<pre>
[r,f] = vl_mser(I') ;
[i,j] = sub2ind(size(I'),r) ;
r  = ind2sub(size(I),j,i) ; 
</pre>

<p>The command line utility <code>mser</code> uses the normal image
convention (because images are rasterized in column-major
order). Therefore the image frames are in the standard format, and the
region seeds are in column major format.</p>

<p>In order to convert from the command line utility convention and
the MATLAB convention one needs also to recall that MATLAB coordinates
starts from (1,1), but the command line utility uses the more common
convention (0,0). For instance, let the files <code>image.frame</code>
and <code>image.seed</code> contain the feature frames and seeds in
ASCII format as generated by the command line utility. Then</p>

<pre>
r_ = load('image.seed')' + 1 ;
f_ = load('image.frame')' ; 
f_(1:2,:) = f_(1:2,:) + 1 ;
[r,f] = vl_mser(I') ; % notice the transpose
</pre>

<p>produces identical (up to numerical noise) region
seeds <code>r</code> and <code>r_</code> and frames <code>f</code>
and <code>f_</code>.</p>
